import numpy as np
import pandas as pd
import argparse
import os
def user_input():
	parser = argparse.ArgumentParser()
	parser.add_argument('-f', help='Path to CG structure generated by martinize2 using the -govs-include -govs-moltype flags')
	parser.add_argument('--molname', default='molecule_0', help='Molecule name used as prefix in your output file names and the virtual bead names (default: molecule_0). If you will combine your Go-like model with a coarse-grained protein generated with martinize2, you must use the same name as specified with the --govs-moltype flag of martinize2!')
	parser.add_argument('--contact_map', default='go_contacts.txt', help='Contact map file calculated by http://pomalab.ippt.pan.pl/GoContactMap/ using the AA structure (default="go_contacts.txt")')
	parser.add_argument('--vsdefinition', default='BB-part-def_VirtGoSites', help='File name suffix used for the .itp file containing the virtual site particles definitions (default="BB-part-def_VirtGoSites")')
	parser.add_argument('--vstable', default='go-table_VirtGoSites', help='File name suffix used for the .itp file containing the virtual site particles definitions (default="BB-part-def_VirtGoSites")')
	parser.add_argument('--vsharm', default='go4view_harm', help='File name suffix containing the GO contacts defined as harmonic bonds. Useful for visualizations.')
	parser.add_argument('--exclusion',default='exclusions_VirtGoSites',help='File name suffix for .itp containing inteaction exlusion between BB atoms already treated with GO potentials.')
	return parser.parse_args()
def load_contacts(path):
	file=open(path).readlines()
	file=file[file.index(" R1    I1 C1  R2    I2 C2        dCA  OV  rCSU\n"):]
	tmpfile=open("tmp_"+path,"w")
	[tmpfile.write(line) for line in file]
	tmpfile.close()
	table=pd.read_table("tmp_"+path,delim_whitespace=True)
	os.system(f"rm tmp_{path}")
	return table
def load_cg_structure(path):
	#table=pd.read_table(path,delim_whitespace=True,names=["Type","Index","Bead","Residue","Chain","Number","x","y","z","bfactor","occupancy"])
	os.system(f'grep "ATOM" {path} > tmp_{path}')
	colspecs=[(0, 6), (6, 11), (12, 16), (17, 20), (21, 22), (22, 26), (30, 38), (38, 46), (46, 54), (54, 60), (60, 66)]
	#table=pd.read_fwf("tmp_"+path,colspecs=colspecs,names=["Type","Index","Bead","Residue","Chain","Number","x","y","z","bfactor","occupancy"])
	table=pd.read_fwf("tmp_"+path,colspecs=colspecs,names=["RowType","Index","Bead","Residue","Chain","Number","x","y","z","bfactor","occupancy"])
	#table=table[table["Type"]=="ATOM"]
	#table["Index"]=table["Index"].map(int)
	os.system(f"rm  tmp_{path}")
	return table
def write_BB_definitions(contacts_table,vsdefinition,molname):
	residues=contacts_table["I1"].drop_duplicates()
	output=open(f"{molname}_{vsdefinition}.itp","w")
	output.write("; protein BB virtual particles\n")
	for r in residues:
	#to be fixed for multiple chains
		output.write(f"{molname}_{r} 0.0 0.000 A 0.0 0.0\n")
	output.close()
def write_BB_interaction_table(contacts_table,vstable,molname):
	output=open(f"{molname}_{vstable}.itp","w")
	output.write("; OV + symmetric rCSU contacts \n")
	for i in range(len(contacts_table)):
		output.write(f' {molname}_{contacts_table["I1"][i]}  {molname}_{contacts_table["I2"][i]}    1  {round(contacts_table["dCA"][i],10)}  12.0000000000  ;\n')		
	output.close()
def write_harmonic_bonds(structure_table,contacts_table,vsharm,molname):
	output=open(f"{molname}_{vsharm}.itp","w")
	output.write("; Go bonds as harmonic bonds between the virtual particles: \n; OV + symmetric rCSU contacts \n")
	residues=structure_table[structure_table["Bead"]=='BB']["Number"].tolist()
	beads=structure_table[structure_table["Bead"]=="CA"]
	for i in range(len(contacts_table)):
		bead1=beads["Index"].tolist()[residues.index(contacts_table["I1"][i])]
		bead2=beads["Index"].tolist()[residues.index(contacts_table["I2"][i])]
		output.write(f"{bead1} {bead2} 1 {round(contacts_table['dCA'][i],4)}  1250 ;{molname}_{contacts_table['I1'][i]} {molname}_{contacts_table['I2'][i]} \n")
def write_exclusion(structure_table,contacts_table,exclusion,molname):
	output=open(f"{molname}_{exclusion}.itp","w")
	residues=structure_table[structure_table["Bead"]=='BB']["Number"].tolist()
	beads=structure_table[structure_table["Bead"]=="BB"]
	for i in range(len(contacts_table)):
		bead1=beads["Index"].tolist()[residues.index(contacts_table["I1"][i])]
		bead2=beads["Index"].tolist()[residues.index(contacts_table["I2"][i])]
		output.write(f"{bead1} {bead2} ;{molname}_{contacts_table['I1'][i]} {molname}_{contacts_table['I2'][i]} \n")
def main():
	args=user_input()
	contacts_table=load_contacts(args.contact_map)
	write_BB_definitions(contacts_table,args.vsdefinition,args.molname)
	write_BB_interaction_table(contacts_table,args.vstable,args.molname)
	structure_table=load_cg_structure(args.f)
	write_harmonic_bonds(structure_table,contacts_table,args.vsharm,args.molname)
	write_exclusion(structure_table,contacts_table,args.exclusion,args.molname)

if __name__ == "__main__":
    main()
