import numpy as np
import pandas as pd
import argparse
import os
def user_input():
	parser = argparse.ArgumentParser()
	parser.add_argument('-f', help='Path to CG structure generated by martinize2 using the -govs-include -govs-moltype flags')
	parser.add_argument('-p', help='Path to the structure topology (.itp) generated by martinize2 using the -govs-include -govs-moltype flags')
	parser.add_argument('--molname', default='molecule_0', help='Molecule name used as prefix in your output file names and the virtual bead names (default: molecule_0). If you will combine your Go-like model with a coarse-grained protein generated with martinize2, you must use the same name as specified with the --govs-moltype flag of martinize2!')
	parser.add_argument('--contact_map', default='go_contacts.txt', help='Contact map file calculated by http://pomalab.ippt.pan.pl/GoContactMap/ using the AA structure (default="go_contacts.txt")')
	parser.add_argument('--map_type', default='pomalab', help='Source of the contact map. Set to "ifpan" to load a contact map from  http://info.ifpan.edu.pl/~rcsu/rcsu/index.html (not implemented yet)')
	parser.add_argument('--vsdefinition', default='BB-part-def_VirtGoSites', help='File name suffix used for the .itp file containing the virtual site particles definitions (default="BB-part-def_VirtGoSites")')
	parser.add_argument('--vstable', default='go-table_VirtGoSites', help='File name suffix used for the .itp file containing the virtual site particles definitions (default="BB-part-def_VirtGoSites")')
	parser.add_argument('--vsharm', default='go4view_harm', help='File name suffix containing the GO contacts defined as harmonic bonds. Useful for visualizations.')
	parser.add_argument('--exclusion',default='exclusions_VirtGoSites',help='File name suffix for .itp containing inteaction exlusion between BB atoms already treated with GO potentials.')
	return parser.parse_args()
def load_contacts_pomalab(path,structure):
	file=open(path).readlines()
	file=file[file.index(" R1    I1 C1  R2    I2 C2        dCA  OV  rCSU\n")+1:]
	file=[x.split() for x in file]
	table=pd.DataFrame(file,columns=['R1', 'I1', 'C1', 'R2', 'I2', 'C2', 'dCA', 'OV', 'rCSU'])
	table["I1"]=table["I1"].map(int)
	table["I2"]=table["I2"].map(int)
	table["dCA"]=table["dCA"].map(float)
	return table
def load_contacts_ifpan(path,structure):
	file=open(path).readlines()
	file=file[file.index("            I1  AA  C I(PDB)    I2  AA  C I(PDB)    DISTANCE       CMs    rCSU    aSurf    rSurf    nSurf\n")+2:file.index("Coordinates of C-alpha atoms\n")-1]
	contacts=pd.DataFrame([x.split() for x in file],columns=['type','number','I1', 'R1', 'C1', 'I1pdb', 'I2', 'R2', 'C2', 'I2pdb', 'dCA', 'OV','CSU','oCSU','rCSU-CM', 'rCSU', 'aSurf', 'rSurf', 'nSurf'])
	structure=structure[structure["Bead"]=="BB"]
	contacts=contacts[["R1","I1","C1","R2","I2","C2","dCA","OV","rCSU"]]
	print(f"{len(contacts)} contacts in file {path}")
	print("Contact map loaded..")
	contacts["I1"]=contacts["I1"].map(int)
	contacts["I2"]=contacts["I2"].map(int)	
	return contacts

def load_contacts(maptype,path,structure):
	if maptype=='pomalab':
		return load_contacts_pomalab(path,structure)
	if maptype=='ifpan':
		return load_contacts_ifpan(path,structure)
	else:
		print(f"Unrecognised map type: {maptype}")
		quit()
def load_structureitp(path):
	file=open(path).readlines()
	atoms=file[file.index("[ atoms ]\n"):file.index("[ position_restraints ]\n")]
	virtualatoms=pd.DataFrame([x.split() for x in atoms if "CA" in x])
	print(f"{len(virtualatoms)} Go beads in file {path}")
	print("Topology loaded...")
	return virtualatoms
def load_cg_structure(path):
	os.system(f'grep "ATOM" {path} > tmp_{path}')
	colspecs=[(0, 6), (6, 11), (12, 16), (17, 20), (21, 22), (22, 26), (30, 38), (38, 46), (46, 54), (54, 60), (60, 66)]
	table=pd.read_fwf("tmp_"+path,colspecs=colspecs,names=["RowType","Index","Bead","Residue","Chain","Number","x","y","z","bfactor","occupancy"])
	os.system(f"rm  tmp_{path}")
	return table
def write_BB_definitions(dictionary,vsdefinition,molname):
	residues=[x[1] for x in dictionary]
	output=open(f"{molname}_{vsdefinition}.itp","w")
	output.write("; protein BB virtual particles\n")
	print(f"Writing {len(residues)} atom definitions in {molname}_{vsdefinition}.itp....",end='')
	for r in residues:
		output.write(f"{r} 0.0 0.000 A 0.0 0.0\n")
	output.close()
	print("Done")
def write_BB_interaction_table(maptype,contacts_table,vstable,molname,dictionary):
	if maptype=='pomalab':
		return write_BB_interaction_table_pomalab(contacts_table,vstable,molname)
	if maptype=='ifpan':
		return write_BB_interaction_table_ifpan(contacts_table,vstable,molname,dictionary)
	else:
		print(f"Unrecognised map type: {maptype}")
def write_BB_interaction_table_ifpan(contacts_table,vstable,molname,dictionary):
	gonames=[x[1] for x in dictionary]
	output=open(f"{molname}_{vstable}.itp","w")
	output.write("; OV + symmetric rCSU contacts \n")
	print(f"Writing {len(contacts_table)} contacts in {molname}_{vstable}.itp....",end='')
	for i in range(len(contacts_table)):
		output.write(f' {gonames[int(contacts_table["I1"][i])-1]}  {gonames[int(contacts_table["I2"][i])-1]}    1  {round(float(contacts_table["dCA"][i]),10)}  12.0000000000  ;\n')		
	output.close()
	print("Done.")

def write_BB_interaction_table_pomalab(contacts_table,vstable,molname):
	output=open(f"{molname}_{vstable}.itp","w")
	output.write("; OV + symmetric rCSU contacts \n")
	for i in range(len(contacts_table)):
		output.write(f' {molname}_{contacts_table["I1"][i]}  {molname}_{contacts_table["I2"][i]}    1  {round(float(contacts_table["dCA"][i]),10)}  12.0000000000  ;\n')		
	output.close()

def write_harmonic_bonds(maptype,structure_table,contacts_table,vsharm,molname):
	if maptype=="pomalab":
		return write_harmonic_bonds_pomalab(structure_table,contacts_table,vsharm,molname)
	if maptype=="ifpan":
		return write_harmonic_bonds_ifpan(structure_table,contacts_table,vsharm,molname)
	else:
		print(f"Unrecognised map type: {maptype}")
		quit()
def write_harmonic_bonds_ifpan(structure_table,contacts_table,vsharm,molname):
	output=open(f"{molname}_{vsharm}.itp","w")
	output.write("; Go bonds as harmonic bonds between the virtual particles: \n; OV + symmetric rCSU contacts \n")
	beads=structure_table[structure_table["Bead"]=="CA"].reset_index(drop=True)
	for i in range(len(contacts_table)):
		bead1=beads["Index"][int(contacts_table["I1"][i])-1]
		bead2=beads["Index"][int(contacts_table["I2"][i])-1]
		output.write(f"{bead1} {bead2} 1 {round(float(contacts_table['dCA'][i]),4)}  1250 ; \n")

def write_harmonic_bonds_pomalab(structure_table,contacts_table,vsharm,molname):
	output=open(f"{molname}_{vsharm}.itp","w")
	output.write("; Go bonds as harmonic bonds between the virtual particles: \n; OV + symmetric rCSU contacts \n")
	residues=structure_table[structure_table["Bead"]=='BB']["Number"].tolist()
	beads=structure_table[structure_table["Bead"]=="CA"]
	for i in range(len(contacts_table)):
		bead1=beads["Index"].tolist()[residues.index(contacts_table["I1"][i])]
		bead2=beads["Index"].tolist()[residues.index(contacts_table["I2"][i])]
		output.write(f"{bead1} {bead2} 1 {round(contacts_table['dCA'][i],4)}  1250 ;{molname}_{contacts_table['I1'][i]} {molname}_{contacts_table['I2'][i]} \n")
def write_exclusion(maptype,structure_table,contacts_table,exclusion,molname,dictionary):
	if maptype=="pomalab":
		return write_exclusion_pomalab(structure_table,contacts_table,exclusion,molname)
	if maptype=='ifpan':
		return write_exclusion_ifpan(structure_table,contacts_table,exclusion,molname,dictionary)
	else:
		print(f"Unrecognised map type: {maptype}")

def write_exclusion_ifpan(structure_table,contacts_table,exclusion,molname,dictionary):
	bbnames=[x[0] for x in dictionary]
	output=open(f"{molname}_{exclusion}.itp","w")
	beads=structure_table[structure_table["Bead"]=="BB"].reset_index(drop=True)
	for i in range(len(contacts_table)):
		bead1=beads["Index"][int(contacts_table["I1"][i])-1]
		bead2=beads["Index"][int(contacts_table["I2"][i])-1]
		output.write(f"{bead1} {bead2} ;{bbnames[int(contacts_table['I1'][i])-1]} {bbnames[int(contacts_table['I2'][i])-1]} \n")

def write_exclusion_pomalab(structure_table,contacts_table,exclusion,molname):
	output=open(f"{molname}_{exclusion}.itp","w")
	residues=structure_table[structure_table["Bead"]=='BB']["Number"].tolist()
	beads=structure_table[structure_table["Bead"]=="BB"]
	for i in range(len(contacts_table)):
		bead1=beads["Index"].tolist()[residues.index(contacts_table["I1"][i])]
		bead2=beads["Index"].tolist()[residues.index(contacts_table["I2"][i])]
		output.write(f"{bead1} {bead2} ;{molname}_{contacts_table['I1'][i]} {molname}_{contacts_table['I2'][i]} \n")
def create_dictionary(structure_table,structureitp):
	names=list(structureitp[1])
	BBs=structure_table[structure_table["Bead"]=="BB"]
	if len(BBs)!=len(names):
		print("Number of atoms in .itp file and CG pdb file do not match")
		quit()
	chains=list(BBs["Chain"])
	res=list(BBs["Number"])
	dictionary=[]
	for i in range(len(BBs)):
		dictionary.append([chains[i]+"_"+str(res[i]),names[i]])
	return dictionary
def main():
	args=user_input()
	structure_table=load_cg_structure(args.f)
	structureitp=load_structureitp(args.p)
	dictionary=create_dictionary(structure_table,structureitp)
	contacts_table=load_contacts(args.map_type,args.contact_map,structure_table)

	write_BB_definitions(dictionary,args.vsdefinition,args.molname)
	write_BB_interaction_table(args.map_type,contacts_table,args.vstable,args.molname,dictionary)
	write_harmonic_bonds(args.map_type,structure_table,contacts_table,args.vsharm,args.molname)
	write_exclusion(args.map_type,structure_table,contacts_table,args.exclusion,args.molname,dictionary)

if __name__ == "__main__":
    main()
